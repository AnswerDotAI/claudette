# claudette


<!-- WARNING: THIS FILE WAS AUTOGENERATED! DO NOT EDIT! -->

> **NB**: If you are reading this in GitHub’s readme, we recommend you
> instead read the much more nicely formatted [documentation
> format](https://claudette.answer.ai/) of this tutorial.

*Claudette* is a wrapper for Anthropic’s [Python
SDK](https://github.com/anthropics/anthropic-sdk-python).

The SDK works well, but it is quite low level – it leaves the developer
to do a lot of stuff manually. That’s a lot of extra work and
boilerplate! Claudette automates pretty much everything that can be
automated, whilst providing full control. Amongst the features provided:

- A [`Chat`](https://claudette.answer.ai/core.html#chat) class that
  creates stateful dialogs
- Support for *prefill*, which tells Claude what to use as the first few
  words of its response
- Convenient image support
- Simple and convenient support for Claude’s new Tool Use API.

You’ll need to set the `ANTHROPIC_API_KEY` environment variable to the
key provided to you by Anthropic in order to use this library.

Note that this library is the first ever “literate nbdev” project. That
means that the actual source code for the library is a rendered Jupyter
Notebook which includes callout notes and tips, HTML tables and images,
detailed explanations, and teaches *how* and *why* the code is written
the way it is. Even if you’ve never used the Anthropic Python SDK or
Claude API before, you should be able to read the source code. Click
[Claudette’s Source](https://claudette.answer.ai/core.html) to read it,
or clone the git repo and execute the notebook yourself to see every
step of the creation process in action. The tutorial below includes
links to API details which will take you to relevant parts of the
source. The reason this project is a new kind of literal program is
because we take seriously Knuth’s call to action, that we have a “*moral
commitment*” to never write an “*illiterate program*” – and so we have a
commitment to making literate programming and easy and pleasant
experience. (For more on this, see [this
talk](https://www.youtube.com/watch?v=rX1yGxJijsI) from Hamel Husain.)

> “*Let us change our traditional attitude to the construction of
> programs: Instead of imagining that our main task is to instruct a
> **computer** what to do, let us concentrate rather on explaining to
> **human beings** what we want a computer to do.*” Donald E. Knuth,
> [Literate
> Programming](https://www.cs.tufts.edu/~nr/cs257/archive/literate-programming/01-knuth-lp.pdf)
> (1984)

## Install

``` sh
pip install claudette
```

## Getting started

Anthropic’s Python SDK will automatically be installed with Claudette,
if you don’t already have it.

``` python
import os
# os.environ['ANTHROPIC_LOG'] = 'debug'
```

To print every HTTP request and response in full, uncomment the above
line.

``` python
from claudette import *
```

Claudette only exports the symbols that are needed to use the library,
so you can use `import *` to import them. Alternatively, just use:

``` python
import claudette
```

…and then add the prefix `claudette.` to any usages of the module.

Claudette provides `models`, which is a list of models currently
available from the SDK.

``` python
models
```

    ('claude-3-opus-20240229',
     'claude-3-5-sonnet-20240620',
     'claude-3-haiku-20240307')

For these examples, we’ll use Sonnet 3.5, since it’s awesome!

``` python
model = models[1]
```

## Chat

The main interface to Claudette is the
[`Chat`](https://claudette.answer.ai/core.html#chat) class, which
provides a stateful interface to Claude:

``` python
chat = Chat(model, sp="""You are a helpful and concise assistant.""")
chat("I'm Jeremy")
```

Hello Jeremy, it’s nice to meet you. How can I assist you today?

<details>

- id: `msg_01UMpEJEVgTVAmK1yqMh9KvM`
- content:
  `[{'text': "Hello Jeremy, it's nice to meet you. How can I assist you today?", 'type': 'text'}]`
- model: `claude-3-5-sonnet-20240620`
- role: `assistant`
- stop_reason: `end_turn`
- stop_sequence: `None`
- type: `message`
- usage:
  `{'input_tokens': 19, 'output_tokens': 20, 'cache_creation_input_tokens': 0, 'cache_read_input_tokens': 0}`
- tool_results: `[]`

</details>

``` python
r = chat("What's my name?")
r
```

Your name is Jeremy, as you just told me.

<details>

- id: `msg_01XJuSMNEMLFzX3LX3YwBRrr`
- content:
  `[{'text': 'Your name is Jeremy, as you just told me.', 'type': 'text'}]`
- model: `claude-3-5-sonnet-20240620`
- role: `assistant`
- stop_reason: `end_turn`
- stop_sequence: `None`
- type: `message`
- usage:
  `{'input_tokens': 47, 'output_tokens': 14, 'cache_creation_input_tokens': 0, 'cache_read_input_tokens': 0}`
- tool_results: `[]`

</details>

As you see above, displaying the results of a call in a notebook shows
just the message contents, with the other details hidden behind a
collapsible section. Alternatively you can `print` the details:

``` python
print(r)
```

    Message(id='msg_01XJuSMNEMLFzX3LX3YwBRrr', content=[TextBlock(text='Your name is Jeremy, as you just told me.', type='text')], model='claude-3-5-sonnet-20240620', role='assistant', stop_reason='end_turn', stop_sequence=None, type='message', usage=In: 47; Out: 14; Total: 61, tool_results=[])

Claude supports adding an extra `assistant` message at the end, which
contains the *prefill* – i.e. the text we want Claude to assume the
response starts with. Let’s try it out:

``` python
chat("Concisely, what is the meaning of life?",
     prefill='According to Douglas Adams,')
```

According to Douglas Adams, “42.” More seriously, it’s often considered
to be finding personal fulfillment, happiness, and purpose.

<details>

- id: `msg_012TCwvsYFR4kdAQtSp7PLDM`
- content:
  `[{'text': 'According to Douglas Adams,  "42." More seriously, it\'s often considered to be finding personal fulfillment, happiness, and purpose.', 'type': 'text'}]`
- model: `claude-3-5-sonnet-20240620`
- role: `assistant`
- stop_reason: `end_turn`
- stop_sequence: `None`
- type: `message`
- usage:
  `{'input_tokens': 81, 'output_tokens': 27, 'cache_creation_input_tokens': 0, 'cache_read_input_tokens': 0}`
- tool_results: `[]`

</details>

You can add `stream=True` to stream the results as soon as they arrive
(although you will only see the gradual generation if you execute the
notebook yourself, of course!)

``` python
for o in chat("Concisely, what book was that in?", prefill='It was in', stream=True):
    print(o, end='')
```

    It was in "The Hitchhiker's Guide to the Galaxy" by Douglas Adams.

### Async

Alternatively, you can use
[`AsyncChat`](https://claudette.answer.ai/async.html#asyncchat) (or
[`AsyncClient`](https://claudette.answer.ai/async.html#asyncclient)) for
the async versions, e.g:

``` python
chat = AsyncChat(model)
await chat("I'm Jeremy")
```

Hello Jeremy! It’s nice to meet you. How can I assist you today? Is
there anything specific you’d like to talk about or any questions you
have?

<details>

- id: `msg_019JMWNfCEEs9CNufVuu7ZZR`
- content:
  `[{'text': "Hello Jeremy! It's nice to meet you. How can I assist you today? Is there anything specific you'd like to talk about or any questions you have?", 'type': 'text'}]`
- model: `claude-3-5-sonnet-20240620`
- role: `assistant`
- stop_reason: `end_turn`
- stop_sequence: `None`
- type: `message`
- usage:
  `{'input_tokens': 10, 'output_tokens': 36, 'cache_creation_input_tokens': 0, 'cache_read_input_tokens': 0}`

</details>

Remember to use `async for` when streaming in this case:

``` python
async for o in await chat("Concisely, what is the meaning of life?",
                          prefill='According to Douglas Adams,', stream=True):
    print(o, end='')
```

    According to Douglas Adams,  the meaning of life is 42. More seriously, there's no universally agreed upon answer. Common perspectives include:

    1. Finding personal happiness and fulfillment
    2. Serving others or a higher purpose
    3. Creating meaning through our choices and actions
    4. Experiencing and appreciating existence
    5. Evolving and growing as individuals and as a species

    Ultimately, many believe each person must define their own meaning of life.

## Prompt caching

If you use `mk_msg(msg, cache=True)`, then the message is cached using
Claude’s [prompt
caching](https://docs.anthropic.com/en/docs/build-with-claude/prompt-caching)
feature. For instance, here we use caching when asking about Claudette’s
readme file:

``` python
chat = Chat(model, sp="""You are a helpful and concise assistant.""")
```

``` python
nbtxt = Path('README.txt').read_text()
msg = f'''<README>
{nbtxt}
</README>
In brief, what is the purpose of this project based on the readme?'''
r = chat(mk_msg(msg, cache=True))
r
```

Based on the readme, the main purpose of the Claudette project is to
provide a high-level wrapper for Anthropic’s Python SDK for interacting
with Claude AI models. Key aspects include:

1.  Automating and simplifying interactions with Claude, reducing
    boilerplate code.

2.  Providing a stateful Chat class for managing conversations.

3.  Supporting features like prefill, image handling, and tool use.

4.  Offering a more convenient interface while maintaining full control.

5.  Being the first “literate nbdev” project, meaning the source code is
    a rendered Jupyter Notebook with detailed explanations, making it
    educational and easy to understand.

6.  Supporting multiple model providers including Anthropic directly,
    Amazon Bedrock, and Google Vertex.

The project aims to make working with Claude models more accessible and
efficient for developers while also serving as an educational resource
on how to build such interfaces.

<details>

- id: `msg_01QZQ8SJZYM8FtFMTBe1gPUS`
- content:
  `[{'text': 'Based on the readme, the main purpose of the Claudette project is to provide a high-level wrapper for Anthropic\'s Python SDK for interacting with Claude AI models. Key aspects include:\n\n1. Automating and simplifying interactions with Claude, reducing boilerplate code.\n\n2. Providing a stateful Chat class for managing conversations.\n\n3. Supporting features like prefill, image handling, and tool use.\n\n4. Offering a more convenient interface while maintaining full control.\n\n5. Being the first "literate nbdev" project, meaning the source code is a rendered Jupyter Notebook with detailed explanations, making it educational and easy to understand.\n\n6. Supporting multiple model providers including Anthropic directly, Amazon Bedrock, and Google Vertex.\n\nThe project aims to make working with Claude models more accessible and efficient for developers while also serving as an educational resource on how to build such interfaces.', 'type': 'text'}]`
- model: `claude-3-5-sonnet-20240620`
- role: `assistant`
- stop_reason: `end_turn`
- stop_sequence: `None`
- type: `message`
- usage:
  `{'input_tokens': 4, 'output_tokens': 196, 'cache_creation_input_tokens': 7171, 'cache_read_input_tokens': 0}`
- tool_results: `[]`

</details>

The response records the a cache has been created using these input
tokens:

``` python
print(r.usage)
```

    Usage(input_tokens=4, output_tokens=196, cache_creation_input_tokens=7171, cache_read_input_tokens=0)

We can now ask a followup question in this chat:

``` python
r = chat('How does it make tool use more ergonomic?')
r
```

Claudette makes tool use more ergonomic in several ways:

1.  Simplified function definition: It uses docments to make defining
    Python functions for tools as simple as possible. Each parameter and
    the return value should have a type and a description.

2.  Automatic handling: When Claude decides to use a tool, Claudette
    automatically handles the process of calling the tool and feeding
    the result back to Claude.

3.  Single-step execution: The
    [`Chat.toolloop`](https://claudette.answer.ai/toolloop.html#chat.toolloop)
    method allows for executing multiple tool calls in a single step,
    handling the back-and-forth between Claude and the tools
    automatically.

4.  Easy tool registration: Tools are simply passed as a list to the
    Chat constructor, making it easy to add or change available tools.

5.  Forced tool use: You can set `tool_choice` to force Claude to always
    answer using a specific tool.

6.  Tracing: The `toolloop` method supports a `trace_func` parameter,
    allowing you to see each response from Claude in the process, which
    is useful for debugging and understanding the tool use flow.

7.  System prompt integration: It allows setting a system prompt to
    guide Claude’s behavior when using tools, like instructing it not to
    mention the tools it’s using.

These features significantly reduce the amount of code and manual
handling required to implement tool use with Claude, making the process
more streamlined and developer-friendly.

<details>

- id: `msg_01MYyXnvV6gV5eBAhWHwDMf9`
- content:
  `[{'text': "Claudette makes tool use more ergonomic in several ways:\n\n1. Simplified function definition: It uses docments to make defining Python functions for tools as simple as possible. Each parameter and the return value should have a type and a description.\n\n2. Automatic handling: When Claude decides to use a tool, Claudette automatically handles the process of calling the tool and feeding the result back to Claude.\n\n3. Single-step execution: The [`Chat.toolloop`](https://claudette.answer.ai/toolloop.html#chat.toolloop) method allows for executing multiple tool calls in a single step, handling the back-and-forth between Claude and the tools automatically.\n\n4. Easy tool registration: Tools are simply passed as a list to the Chat constructor, making it easy to add or change available tools.\n\n5. Forced tool use: You can set`tool_choice`to force Claude to always answer using a specific tool.\n\n6. Tracing: The`toolloop`method supports a`trace_func`parameter, allowing you to see each response from Claude in the process, which is useful for debugging and understanding the tool use flow.\n\n7. System prompt integration: It allows setting a system prompt to guide Claude's behavior when using tools, like instructing it not to mention the tools it's using.\n\nThese features significantly reduce the amount of code and manual handling required to implement tool use with Claude, making the process more streamlined and developer-friendly.", 'type': 'text'}]`
- model: `claude-3-5-sonnet-20240620`
- role: `assistant`
- stop_reason: `end_turn`
- stop_sequence: `None`
- type: `message`
- usage:
  `{'input_tokens': 216, 'output_tokens': 295, 'cache_creation_input_tokens': 0, 'cache_read_input_tokens': 7171}`
- tool_results: `[]`

</details>

We can see that this only used ~200 regular input tokens – the 7000+
context tokens have been read from cache.

``` python
print(r.usage)
```

    Usage(input_tokens=216, output_tokens=295, cache_creation_input_tokens=0, cache_read_input_tokens=7171)

## Tool use

[Tool use](https://docs.anthropic.com/claude/docs/tool-use) lets Claude
use external tools.

We use [docments](https://fastcore.fast.ai/docments.html) to make
defining Python functions as ergonomic as possible. Each parameter (and
the return value) should have a type, and a docments comment with the
description of what it is. As an example we’ll write a simple function
that adds numbers together, and will tell us when it’s being called:

``` python
def sums(
    a:int,  # First thing to sum
    b:int=1 # Second thing to sum
) -> int: # The sum of the inputs
    "Adds a + b."
    print(f"Finding the sum of {a} and {b}")
    return a + b
```

Sometimes Claude will say something like “according to the `sums` tool
the answer is” – generally we’d rather it just tells the user the
answer, so we can use a system prompt to help with this:

``` python
sp = "Never mention what tools you use."
```

We’ll get Claude to add up some long numbers:

``` python
a,b = 604542,6458932
pr = f"What is {a}+{b}?"
pr
```

    'What is 604542+6458932?'

To use tools, pass a list of them to
[`Chat`](https://claudette.answer.ai/core.html#chat), and to force it to
always answer using a tool, set `tool_choice` to that function name:

``` python
chat = Chat(model, sp=sp, tools=[sums], tool_choice='sums')
```

Now when we call that with our prompt, Claude doesn’t return the answer,
but instead returns a `tool_use` message, which means we have to call
the named tool with the provided parameters:

``` python
r = chat(pr)
r
```

    Finding the sum of 604542 and 6458932

ToolUseBlock(id=‘toolu_011uoKUrsAgjhprPs7bFYYJW’, input={‘a’: 604542,
‘b’: 6458932}, name=‘sums’, type=‘tool_use’)

<details>

- id: `msg_01UjzVDubCyTaSS7Sr7vxs2B`
- content:
  `[{'id': 'toolu_011uoKUrsAgjhprPs7bFYYJW', 'input': {'a': 604542, 'b': 6458932}, 'name': 'sums', 'type': 'tool_use'}]`
- model: `claude-3-5-sonnet-20240620`
- role: `assistant`
- stop_reason: `tool_use`
- stop_sequence: `None`
- type: `message`
- usage:
  `{'input_tokens': 414, 'output_tokens': 53, 'cache_creation_input_tokens': 0, 'cache_read_input_tokens': 0}`
- tool_results:
  `[{'type': 'tool_result', 'tool_use_id': 'toolu_011uoKUrsAgjhprPs7bFYYJW', 'content': 7063474}]`

</details>

Claudette handles all that for us – we just call it again, and it all
happens automatically:

``` python
chat()
```

The sum of 604542 and 6458932 is 7063474.

<details>

- id: `msg_01R6kssPpVFF9D8AY94NKbUT`
- content:
  `[{'text': 'The sum of 604542 and 6458932 is 7063474.', 'type': 'text'}]`
- model: `claude-3-5-sonnet-20240620`
- role: `assistant`
- stop_reason: `end_turn`
- stop_sequence: `None`
- type: `message`
- usage:
  `{'input_tokens': 515, 'output_tokens': 23, 'cache_creation_input_tokens': 0, 'cache_read_input_tokens': 0}`
- tool_results: `[]`

</details>

We can also directly access the result of the tool call from the
response object.

``` python
r.tool_results
```

    [{'type': 'tool_result',
      'tool_use_id': 'toolu_011uoKUrsAgjhprPs7bFYYJW',
      'content': 7063474}]

You can see how many tokens have been used at any time by checking the
`use` property. Note that (as of May 2024) tool use in Claude uses a
*lot* of tokens, since it automatically adds a large system prompt.

``` python
chat.use
```

    In: 929; Out: 76; Total: 1005

We can do everything needed to use tools in a single step, by using
[`Chat.toolloop`](https://claudette.answer.ai/toolloop.html#chat.toolloop).
This can even call multiple tools as needed solve a problem. For
example, let’s define a tool to handle multiplication:

``` python
def mults(
    a:int,  # First thing to multiply
    b:int=1 # Second thing to multiply
) -> int: # The product of the inputs
    "Multiplies a * b."
    print(f"Finding the product of {a} and {b}")
    return a * b
```

Now with a single call we can calculate `(a+b)*2` – by passing
`show_trace` we can see each response from Claude in the process:

``` python
chat = Chat(model, sp=sp, tools=[sums,mults])
pr = f'Calculate ({a}+{b})*2'
pr
```

    'Calculate (604542+6458932)*2'

``` python
chat.toolloop(pr, trace_func=print)
```

    Finding the sum of 604542 and 6458932
    Message(id='msg_01Lg9vmU9inCRtWM4ZksKWDh', content=[TextBlock(text='Certainly! To calculate (604542+6458932)*2, we\'ll need to use the available tools to perform the addition and multiplication operations. Let\'s break it down step by step:\n\n1. First, we\'ll add 604542 and 6458932 using the "sums" function.\n2. Then, we\'ll multiply the result by 2 using the "mults" function.\n\nLet\'s start with the addition:', type='text'), ToolUseBlock(id='toolu_01NzsLJ2jFiU2LkNbGbT7zsX', input={'a': 604542, 'b': 6458932}, name='sums', type='tool_use')], model='claude-3-5-sonnet-20240620', role='assistant', stop_reason='tool_use', stop_sequence=None, type='message', usage=In: 538; Out: 168; Total: 706, tool_results=[{'type': 'tool_result', 'tool_use_id': 'toolu_01NzsLJ2jFiU2LkNbGbT7zsX', 'content': 7063474}])
    Finding the product of 7063474 and 2
    Message(id='msg_01KxCVavN7ckdvg2GHqZJimC', content=[TextBlock(text="Great! The sum of 604542 and 6458932 is 7063474.\n\nNow, let's multiply this result by 2:", type='text'), ToolUseBlock(id='toolu_015pjYz8MZnsNpMgeytAqrdt', input={'a': 7063474, 'b': 2}, name='mults', type='tool_use')], model='claude-3-5-sonnet-20240620', role='assistant', stop_reason='tool_use', stop_sequence=None, type='message', usage=In: 721; Out: 106; Total: 827, tool_results=[{'type': 'tool_result', 'tool_use_id': 'toolu_015pjYz8MZnsNpMgeytAqrdt', 'content': 14126948}])
    Message(id='msg_013ovXsD1PZ14hiYQRvCfHYD', content=[TextBlock(text='Now we have our final result. \n\nThe calculation (604542+6458932)*2 equals 14126948.\n\nTo break it down:\n1. 604542 + 6458932 = 7063474\n2. 7063474 * 2 = 14126948\n\nSo, the final answer to (604542+6458932)*2 is 14126948.', type='text')], model='claude-3-5-sonnet-20240620', role='assistant', stop_reason='end_turn', stop_sequence=None, type='message', usage=In: 841; Out: 95; Total: 936, tool_results=[])

Now we have our final result.

The calculation (604542+6458932)\*2 equals 14126948.

To break it down: 1. 604542 + 6458932 = 7063474 2. 7063474 \* 2 =
14126948

So, the final answer to (604542+6458932)\*2 is 14126948.

<details>

- id: `msg_013ovXsD1PZ14hiYQRvCfHYD`
- content:
  `[{'text': 'Now we have our final result. \n\nThe calculation (604542+6458932)*2 equals 14126948.\n\nTo break it down:\n1. 604542 + 6458932 = 7063474\n2. 7063474 * 2 = 14126948\n\nSo, the final answer to (604542+6458932)*2 is 14126948.', 'type': 'text'}]`
- model: `claude-3-5-sonnet-20240620`
- role: `assistant`
- stop_reason: `end_turn`
- stop_sequence: `None`
- type: `message`
- usage:
  `{'input_tokens': 841, 'output_tokens': 95, 'cache_creation_input_tokens': 0, 'cache_read_input_tokens': 0}`
- tool_results: `[]`

</details>

We can also utilize Claudette’s tool calling to perform structure
generation. Here is an example of using tool use to synthetically
generate a conversation between two people.

``` python
class Turn:
    """A turn in the conversation."""
    def __init__(
        self,
        user_a: str, # The first user's message
        user_b: str, # The second user's message
    ): store_attr()
    
    __repr__ = basic_repr(['user_a', 'user_b'])
    def __str__(self): return "Turn created."

class Conversation:
    """A conversation between two users."""
    def __init__(
        self,
        turns: List[Turn], # The turns in the conversation
    ): store_attr()
    
    __repr__ = basic_repr('turns')
    def __str__(self): return "Conversation created."

Conversation([Turn("Hi, I'm Jeremy", "Hi, I'm Clara.")])
```

    __main__.Conversation(turns=[__main__.Turn(user_a="Hi, I'm Jeremy", user_b="Hi, I'm Clara.")])

``` python
chat = Chat(model, sp=sp, tools=[Conversation], tool_choice='Conversation')
pr = "Conversation between Jeremy and Clara"
```

``` python
r = chat(pr)
r
```

ToolUseBlock(id=‘toolu_01Gv4zkjacei5vDqB5e4YDvU’, input={‘turns’:
\[{‘speaker’: ‘Jeremy’, ‘text’: ‘Hi Clara, how are you doing today?’},
{‘speaker’: ‘Clara’, ‘text’: “Hello Jeremy! I’m doing well, thanks for
asking. How about you?”}, {‘speaker’: ‘Jeremy’, ‘text’: “I’m good,
thanks. I was wondering if you’d like to grab coffee sometime this
week?”}, {‘speaker’: ‘Clara’, ‘text’: “That sounds lovely! I’m free on
Wednesday afternoon if that works for you.”}, {‘speaker’: ‘Jeremy’,
‘text’: ‘Wednesday afternoon works perfectly for me. Shall we say 3 PM
at the café on Main Street?’}, {‘speaker’: ‘Clara’, ‘text’: “3 PM at the
café on Main Street sounds great. I’ll see you then, Jeremy!”},
{‘speaker’: ‘Jeremy’, ‘text’: ‘Excellent! Looking forward to it, Clara.
See you on Wednesday!’}\]}, name=‘Conversation’, type=‘tool_use’)

<details>

- id: `msg_01AqAntpLd3zRAcN8sYDoEpd`
- content:
  `[{'id': 'toolu_01Gv4zkjacei5vDqB5e4YDvU', 'input': {'turns': [{'speaker': 'Jeremy', 'text': 'Hi Clara, how are you doing today?'}, {'speaker': 'Clara', 'text': "Hello Jeremy! I'm doing well, thanks for asking. How about you?"}, {'speaker': 'Jeremy', 'text': "I'm good, thanks. I was wondering if you'd like to grab coffee sometime this week?"}, {'speaker': 'Clara', 'text': "That sounds lovely! I'm free on Wednesday afternoon if that works for you."}, {'speaker': 'Jeremy', 'text': 'Wednesday afternoon works perfectly for me. Shall we say 3 PM at the café on Main Street?'}, {'speaker': 'Clara', 'text': "3 PM at the café on Main Street sounds great. I'll see you then, Jeremy!"}, {'speaker': 'Jeremy', 'text': 'Excellent! Looking forward to it, Clara. See you on Wednesday!'}]}, 'name': 'Conversation', 'type': 'tool_use'}]`
- model: `claude-3-5-sonnet-20240620`
- role: `assistant`
- stop_reason: `tool_use`
- stop_sequence: `None`
- type: `message`
- usage:
  `{'input_tokens': 373, 'output_tokens': 295, 'cache_creation_input_tokens': 0, 'cache_read_input_tokens': 0}`
- tool_results:
  `[{'type': 'tool_result', 'tool_use_id': 'toolu_01Gv4zkjacei5vDqB5e4YDvU', 'content': __main__.Conversation(turns=[{'speaker': 'Jeremy', 'text': 'Hi Clara, how are you doing today?'}, {'speaker': 'Clara', 'text': "Hello Jeremy! I'm doing well, thanks for asking. How about you?"}, {'speaker': 'Jeremy', 'text': "I'm good, thanks. I was wondering if you'd like to grab coffee sometime this week?"}, {'speaker': 'Clara', 'text': "That sounds lovely! I'm free on Wednesday afternoon if that works for you."}, {'speaker': 'Jeremy', 'text': 'Wednesday afternoon works perfectly for me. Shall we say 3 PM at the café on Main Street?'}, {'speaker': 'Clara', 'text': "3 PM at the café on Main Street sounds great. I'll see you then, Jeremy!"}, {'speaker': 'Jeremy', 'text': 'Excellent! Looking forward to it, Clara. See you on Wednesday!'}])}]`

</details>

``` python
r.tool_results[0]['content']
```

    __main__.Conversation(turns=[{'speaker': 'Jeremy', 'text': 'Hi Clara, how are you doing today?'}, {'speaker': 'Clara', 'text': "Hello Jeremy! I'm doing well, thanks for asking. How about you?"}, {'speaker': 'Jeremy', 'text': "I'm good, thanks. I was wondering if you'd like to grab coffee sometime this week?"}, {'speaker': 'Clara', 'text': "That sounds lovely! I'm free on Wednesday afternoon if that works for you."}, {'speaker': 'Jeremy', 'text': 'Wednesday afternoon works perfectly for me. Shall we say 3 PM at the café on Main Street?'}, {'speaker': 'Clara', 'text': "3 PM at the café on Main Street sounds great. I'll see you then, Jeremy!"}, {'speaker': 'Jeremy', 'text': 'Excellent! Looking forward to it, Clara. See you on Wednesday!'}])

## Images

Claude can handle image data as well. As everyone knows, when testing
image APIs you have to use a cute puppy.

``` python
fn = Path('samples/puppy.jpg')
display.Image(filename=fn, width=200)
```

<img src="index_files/figure-commonmark/cell-33-output-1.jpeg"
width="200" />

We create a [`Chat`](https://claudette.answer.ai/core.html#chat) object
as before:

``` python
chat = Chat(model)
```

Claudette expects images as a list of bytes, so we read in the file:

``` python
img = fn.read_bytes()
```

Prompts to Claudette can be lists, containing text, images, or both, eg:

``` python
chat([img, "In brief, what color flowers are in this image?"])
```

The flowers in this image are purple. They appear to be small,
daisy-like flowers, possibly asters or some type of purple daisy,
blooming in the background behind the adorable puppy in the foreground.

<details>

- id: `msg_01JKCaLLYPgryrykw9Ny3XLJ`
- content:
  `[{'text': 'The flowers in this image are purple. They appear to be small, daisy-like flowers, possibly asters or some type of purple daisy, blooming in the background behind the adorable puppy in the foreground.', 'type': 'text'}]`
- model: `claude-3-5-sonnet-20240620`
- role: `assistant`
- stop_reason: `end_turn`
- stop_sequence: `None`
- type: `message`
- usage:
  `{'input_tokens': 110, 'output_tokens': 50, 'cache_creation_input_tokens': 0, 'cache_read_input_tokens': 0}`
- tool_results: `[]`

</details>

The image is included as input tokens.

``` python
chat.use
```

    In: 110; Out: 50; Total: 160

Alternatively, Claudette supports creating a multi-stage chat with
separate image and text prompts. For instance, you can pass just the
image as the initial prompt (in which case Claude will make some general
comments about what it sees), and then follow up with questions in
additional prompts:

``` python
chat = Chat(model)
chat(img)
```

This image shows an adorable puppy lying in the grass. The puppy appears
to be a Cavalier King Charles Spaniel or a similar breed, with
distinctive white and reddish-brown fur coloring. Its face is
predominantly white with large, expressive dark eyes and a small black
nose.

The puppy is resting on a grassy surface, and behind it, you can see
some purple flowers, which look like asters or michaelmas daisies. These
flowers add a lovely splash of color to the background. There’s also
what seems to be a wooden structure or fence visible behind the puppy,
giving the scene a rustic, garden-like feel.

The composition of the image is quite charming, with the puppy as the
main focus in the foreground and the natural elements providing a
beautiful, colorful backdrop. The lighting appears soft, highlighting
the puppy’s fur and giving the whole image a warm, inviting atmosphere.

This kind of image would be perfect for a greeting card, calendar, or as
a heartwarming pet portrait. It captures the innocence and cuteness of a
young dog in a picturesque outdoor setting.

<details>

- id: `msg_016mNxpGsU1SRHjdD1wWT6VX`
- content:
  `[{'text': "This image shows an adorable puppy lying in the grass. The puppy appears to be a Cavalier King Charles Spaniel or a similar breed, with distinctive white and reddish-brown fur coloring. Its face is predominantly white with large, expressive dark eyes and a small black nose.\n\nThe puppy is resting on a grassy surface, and behind it, you can see some purple flowers, which look like asters or michaelmas daisies. These flowers add a lovely splash of color to the background. There's also what seems to be a wooden structure or fence visible behind the puppy, giving the scene a rustic, garden-like feel.\n\nThe composition of the image is quite charming, with the puppy as the main focus in the foreground and the natural elements providing a beautiful, colorful backdrop. The lighting appears soft, highlighting the puppy's fur and giving the whole image a warm, inviting atmosphere.\n\nThis kind of image would be perfect for a greeting card, calendar, or as a heartwarming pet portrait. It captures the innocence and cuteness of a young dog in a picturesque outdoor setting.", 'type': 'text'}]`
- model: `claude-3-5-sonnet-20240620`
- role: `assistant`
- stop_reason: `end_turn`
- stop_sequence: `None`
- type: `message`
- usage:
  `{'input_tokens': 98, 'output_tokens': 248, 'cache_creation_input_tokens': 0, 'cache_read_input_tokens': 0}`
- tool_results: `[]`

</details>

``` python
chat('What direction is the puppy facing?')
```

The puppy in the image is facing towards the left side of the frame. Its
head is turned slightly, allowing us to see most of its face, including
both eyes, which are looking directly at the camera. The puppy’s body is
angled diagonally, with its front paws and chest visible as it rests on
the grass. This positioning gives a good view of the puppy’s facial
features and part of its body, creating an engaging and endearing
portrait of the young dog.

<details>

- id: `msg_018JNoAnKYLLMcJ9RrTAn3oz`
- content:
  `[{'text': "The puppy in the image is facing towards the left side of the frame. Its head is turned slightly, allowing us to see most of its face, including both eyes, which are looking directly at the camera. The puppy's body is angled diagonally, with its front paws and chest visible as it rests on the grass. This positioning gives a good view of the puppy's facial features and part of its body, creating an engaging and endearing portrait of the young dog.", 'type': 'text'}]`
- model: `claude-3-5-sonnet-20240620`
- role: `assistant`
- stop_reason: `end_turn`
- stop_sequence: `None`
- type: `message`
- usage:
  `{'input_tokens': 357, 'output_tokens': 105, 'cache_creation_input_tokens': 0, 'cache_read_input_tokens': 0}`
- tool_results: `[]`

</details>

``` python
chat('What color is it?')
```

The puppy in the image has a combination of two main colors:

1.  White: The majority of its face, including the area around its eyes,
    muzzle, and what’s visible of its chest and front legs, is white.

2.  Reddish-brown (often called “chestnut” or “ruby” in dog breed
    descriptions): This color appears on the puppy’s ears and extends to
    patches visible on its back.

This color combination of white and reddish-brown is typical of certain
spaniel breeds, particularly the Cavalier King Charles Spaniel. The
contrast between the white and the reddish-brown fur creates a striking
and adorable appearance for the puppy.

<details>

- id: `msg_01EVoQqTD5X3HY5btoZynEtZ`
- content:
  `[{'text': 'The puppy in the image has a combination of two main colors:\n\n1. White: The majority of its face, including the area around its eyes, muzzle, and what\'s visible of its chest and front legs, is white.\n\n2. Reddish-brown (often called "chestnut" or "ruby" in dog breed descriptions): This color appears on the puppy\'s ears and extends to patches visible on its back.\n\nThis color combination of white and reddish-brown is typical of certain spaniel breeds, particularly the Cavalier King Charles Spaniel. The contrast between the white and the reddish-brown fur creates a striking and adorable appearance for the puppy.', 'type': 'text'}]`
- model: `claude-3-5-sonnet-20240620`
- role: `assistant`
- stop_reason: `end_turn`
- stop_sequence: `None`
- type: `message`
- usage:
  `{'input_tokens': 470, 'output_tokens': 153, 'cache_creation_input_tokens': 0, 'cache_read_input_tokens': 0}`
- tool_results: `[]`

</details>

Note that the image is passed in again for every input in the dialog, so
that number of input tokens increases quickly with this kind of chat.
(For large images, using prompt caching might be a good idea.)

``` python
chat.use
```

    In: 925; Out: 506; Total: 1431

## Other model providers

You can also use 3rd party providers of Anthropic models, as shown here.

### Amazon Bedrock

These are the models available through Bedrock:

``` python
models_aws
```

    ('anthropic.claude-3-haiku-20240307-v1:0',
     'anthropic.claude-3-sonnet-20240229-v1:0',
     'anthropic.claude-3-opus-20240229-v1:0',
     'anthropic.claude-3-5-sonnet-20240620-v1:0')

To use them, call `AnthropicBedrock` with your access details, and pass
that to [`Client`](https://claudette.answer.ai/core.html#client):

``` python
from anthropic import AnthropicBedrock
```

``` python
ab = AnthropicBedrock(
    aws_access_key=os.environ['AWS_ACCESS_KEY'],
    aws_secret_key=os.environ['AWS_SECRET_KEY'],
)
client = Client(models_aws[-1], ab)
```

Now create your [`Chat`](https://claudette.answer.ai/core.html#chat)
object passing this client to the `cli` parameter – and from then on,
everything is identical to the previous examples.

``` python
chat = Chat(cli=client)
chat("I'm Jeremy")
```

Hello Jeremy! It’s nice to meet you. How can I assist you today? Is
there anything specific you’d like to talk about or any questions you
have?

<details>

- id: `msg_bdrk_01VFVE1Pe5LNubaWYKC1sz8f`
- content:
  `[{'text': "Hello Jeremy! It's nice to meet you. How can I assist you today? Is there anything specific you'd like to talk about or any questions you have?", 'type': 'text'}]`
- model: `claude-3-5-sonnet-20240620`
- role: `assistant`
- stop_reason: `end_turn`
- stop_sequence: `None`
- type: `message`
- usage: `{'input_tokens': 10, 'output_tokens': 36}`

</details>

### Google Vertex

These are the models available through Vertex:

``` python
models_goog
```

    ('claude-3-haiku@20240307',
     'claude-3-sonnet@20240229',
     'claude-3-opus@20240229',
     'claude-3-5-sonnet@20240620')

To use them, call `AnthropicVertex` with your access details, and pass
that to [`Client`](https://claudette.answer.ai/core.html#client):

``` python
from anthropic import AnthropicVertex
import google.auth
```

``` python
project_id = google.auth.default()[1]
gv = AnthropicVertex(project_id=project_id, region="us-east5")
client = Client(models_goog[-1], gv)
```

``` python
chat = Chat(cli=client)
chat("I'm Jeremy")
```

Hello Jeremy! It’s nice to meet you. How can I assist you today? Is
there anything specific you’d like to talk about or any questions you
have?

<details>

- id: `msg_vrtx_01P251BUJXBBvihsvb3VVgZ3`
- content:
  `[{'text': "Hello Jeremy! It's nice to meet you. How can I assist you today? Is there anything specific you'd like to talk about or any questions you have?", 'type': 'text'}]`
- model: `claude-3-5-sonnet-20240620`
- role: `assistant`
- stop_reason: `end_turn`
- stop_sequence: `None`
- type: `message`
- usage: `{'input_tokens': 10, 'output_tokens': 36}`

</details>
