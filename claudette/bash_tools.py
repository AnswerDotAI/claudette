"""Tools for executing bash commands and searching files safely."""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../04_bash_tools.ipynb.

# %% auto 0
__all__ = ['DEFAULT_DENY_LIST', 'SAFE_COMMANDS', 'execute', 'find_files', 'grep_files']

# %% ../04_bash_tools.ipynb
import os
import re
import shlex
import subprocess
from pathlib import Path
from typing import Dict, Any, List, Optional

# %% ../04_bash_tools.ipynb
DEFAULT_DENY_LIST = [
    "rm -rf", "sudo", "chmod 777", ":(){ :|:& };:",
    "> /dev/sda", "dd if=/dev/zero", "mkfs", "> /dev/null",
    "mv /* ", "shred", "> /etc/passwd", "wget -O- | sh"
]

# %% ../04_bash_tools.ipynb
SAFE_COMMANDS = [
    "ls", "cat", "echo", "pwd", "cd", "grep", "find",
    "head", "tail", "wc", "file", "mkdir", "touch",
    "diff", "cp", "mv", "du", "df", "ping", "ps"
]

# %% ../04_bash_tools.ipynb
def execute(
    command: str,                                    # Shell command to run
    timeout: int = 30,                               # Maximum execution time in seconds
    allow_list: Optional[List[str]] = None,          # If provided, ONLY these commands will be allowed
    deny_list: Optional[List[str]] = DEFAULT_DENY_LIST  # Commands that will be explicitly blocked
) -> str:
    """Execute a shell command with safety controls via allow/deny lists.
    
    Args:
        command: Shell command to run
        timeout: Maximum execution time in seconds
        allow_list: If provided, ONLY these commands will be allowed
        deny_list: Commands that will be explicitly blocked
    
    Returns:
        Command output or error message
    """
    # Parse command to get the base command
    try:
        cmd_parts = shlex.split(command)
        if not cmd_parts: return "Error: Empty command"
        base_cmd = cmd_parts[0]
        
        # Check allow list if provided
        if allow_list is not None:
            if base_cmd not in allow_list:
                return f"Error: Command '{base_cmd}' not in allowed list. Allowed: {', '.join(allow_list)}"
        
        # Check deny list for exact matches and patterns
        if deny_list:
            for denied in deny_list:
                if command.startswith(denied) or f" {denied}" in command:
                    return f"Error: Command contains denied pattern '{denied}'"
        
        # Execute if safe
        result = subprocess.run(
            command,
            shell=True,  # We need shell=True to run full commands with pipes, etc.
            capture_output=True,
            text=True,
            timeout=timeout
        )
        
        output = result.stdout
        error = result.stderr
        
        if result.returncode != 0:
            return f"Command failed with exit code {result.returncode}.\nError:\n{error}\nOutput:\n{output}"
        
        return f"Command executed successfully.\nOutput:\n{output}"
    except subprocess.TimeoutExpired:
        return f"Error: Command execution timed out after {timeout} seconds"
    except Exception as e:
        return f"Error executing command: {str(e)}"

# %% ../04_bash_tools.ipynb
def find_files(
    pattern: str,                                    # File pattern to match (e.g. "*.py" or "**/*.md")
    path: str = ".",                                 # Directory to search in
    max_depth: int = 3,                              # Maximum directory depth to search
    max_results: int = 100                           # Maximum number of results to return
) -> str:
    """Find files matching a pattern with reasonable limits.
    
    Args:
        pattern: File pattern to match (e.g. "*.py" or "**/*.md")
        path: Directory to search in
        max_depth: Maximum directory depth to search
        max_results: Maximum number of results to return
    
    Returns:
        List of matching files or error message
    """
    try:
        p = Path(path).expanduser().resolve()
        if not p.exists():
            return f"Error: Path '{p}' does not exist"
        
        # Handle max_depth for recursive patterns
        if "**" in pattern and max_depth > 0:
            # Some glob implementations support depth limiting syntax
            glob_pattern = pattern.replace("**", f"**[0-{max_depth}]")
        else:
            glob_pattern = pattern
            
        # Find matching files
        files = list(p.glob(glob_pattern))
        
        # Apply limits
        total_found = len(files)
        files = files[:max_results]
        
        if not files:
            return f"No files matching '{pattern}' found in {p}"
            
        # Format output
        results = '\n'.join(str(f) for f in files)
        
        # Add note if results were limited
        if total_found > max_results:
            results += f"\n\nNote: Showing {max_results} of {total_found} matches. Use a more specific pattern to narrow results."
            
        return results
    except Exception as e:
        return f"Error finding files: {str(e)}"

# %% ../04_bash_tools.ipynb
def grep_files(
    pattern: str,                                    # Pattern to search for
    path: str,                                       # File or directory to search in
    recursive: bool = False,                         # Whether to search recursively
    file_pattern: str = "*",                         # File pattern to limit the search (e.g. "*.py")
    max_results: int = 100                           # Maximum number of matches to return
) -> str:
    """Search for a pattern in files using the grep command.
    
    Args:
        pattern: Pattern to search for
        path: File or directory to search in
        recursive: Whether to search recursively
        file_pattern: File pattern to limit the search (e.g. "*.py")
        max_results: Maximum number of matches to return
    
    Returns:
        Matching lines with file and line numbers
    """
    try:
        p = Path(path).expanduser().resolve()
        if not p.exists():
            return f"Error: Path '{p}' does not exist"
        
        # Build the grep command with appropriate options
        # -n: show line numbers, -H: show filenames
        cmd = ["grep", "-n", "-H"]
        
        # Add recursive flag if requested
        if recursive:
            cmd.append("-r")
        
        # Add the pattern to search for
        cmd.append(pattern)
        
        # Add the path to search
        cmd.append(str(p))
        
        # Add file pattern if not searching all files
        if file_pattern != "*":
            cmd.extend(["--include", file_pattern])
        
        # Run the command with timeout
        result = subprocess.run(
            cmd,
            capture_output=True,
            text=True,
            timeout=30
        )
        
        # If grep returns with exit code 1, it means no matches were found (but not an error)
        if result.returncode == 1 and not result.stderr:
            return f"No matches found for '{pattern}' in {path}"
        
        # If grep returns with another non-zero exit code, it's an error
        if result.returncode != 0 and result.returncode != 1:
            return f"Error searching files: {result.stderr}"
        
        # Split the output into lines and limit the results
        lines = result.stdout.strip().split("\n")
        total_matches = len(lines) if lines and lines[0] else 0
        
        if total_matches == 0:
            return f"No matches found for '{pattern}' in {path}"
        
        # Limit the number of results
        limited_lines = lines[:max_results]
        output = "\n".join(limited_lines)
        
        # Add note if results were limited
        if total_matches > max_results:
            output += f"\n\nNote: Showing {max_results} of {total_matches} matches. Use a more specific pattern to narrow results."
        
        return output
    except subprocess.TimeoutExpired:
        return "Error: Search timed out. Try a more specific pattern or smaller directory."
    except Exception as e:
        return f"Error searching files: {str(e)}"
