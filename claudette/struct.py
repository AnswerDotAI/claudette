# AUTOGENERATED! DO NOT EDIT! File to edit: ../02_struct.ipynb.

# %% auto 0
__all__ = []

# %% ../02_struct.ipynb 3
from .core import *
from fastcore.utils import *
from fastcore.meta import delegates
from pydantic import BaseModel, Field

# %% ../02_struct.ipynb 9
@patch(cls_method=True)
def claude_schema(cls: BaseModel):
    "Create tool schema for claude"
    def _filter_title(obj):
        if isinstance(obj, dict): return {k:_filter_title(v) for k,v in obj.items() if k != 'title'}
        elif isinstance(obj, list): return [_filter_title(item) for item in obj]
        else: return obj
    
    schema = cls.model_json_schema()
    name = schema.pop('title')
    description = schema.pop('description')
    return {
        "name": name,
        "description": description,
        "input_schema": _filter_title(schema)
    }

# %% ../02_struct.ipynb 16
@patch
@delegates(Client.__call__)
def struct(self:Client,
             msgs:list, # List of messages in the dialog
             resp_model: BaseModel, # Non-initialized pydantic struct
             **kwargs
          ) -> BaseModel: # Initialized pydantic struct
    "Parse Claude output into the Pydantic `resp_model`"
    kwargs["tool_choice"] = mk_tool_choice(resp_model.__name__)
    kwargs["tools"] = [resp_model.claude_schema()] # no other tools needed -- model is forced by tool_choice
    fc = self(msgs=msgs, **kwargs)
    res = resp_model(**contents(fc).input)
    return res

# %% ../02_struct.ipynb 22
@patch
@delegates(Client.struct)
def struct(self:Chat,
             resp_model: BaseModel, # Non-initialized pydantic struct
             **kwargs) -> BaseModel:
    self._append_pr(kwargs.pop("pr", None))
    res = self.c.struct(self.h, resp_model=resp_model, **kwargs)
    r = self.c.result
    tool_id = contents(r).id
    msgs = [mk_msg(r, "assistant"),
            mk_msg([mk_funcres(tool_id, res)], "user")]
    self.h += msgs
    return res
